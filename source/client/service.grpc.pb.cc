// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: api/client/service.proto

#include "client/service.grpc.pb.h"
#include "api/client/service.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace nighthawk {
namespace client {

static const char* NighthawkService_method_names[] = {
    "/nighthawk.client.NighthawkService/QueueSession",
    "/nighthawk.client.NighthawkService/ReconfigureSession",
    "/nighthawk.client.NighthawkService/IsSessionFinished",
    "/nighthawk.client.NighthawkService/PopSessionResult",
    "/nighthawk.client.NighthawkService/Shutdown",
};

std::unique_ptr<NighthawkService::Stub>
NighthawkService::NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
                          const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr<NighthawkService::Stub> stub(new NighthawkService::Stub(channel));
  return stub;
}

NighthawkService::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel)
    : channel_(channel), rpcmethod_QueueSession_(NighthawkService_method_names[0],
                                                 ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_ReconfigureSession_(NighthawkService_method_names[1],
                                    ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_IsSessionFinished_(NighthawkService_method_names[2],
                                   ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_PopSessionResult_(NighthawkService_method_names[3],
                                  ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_Shutdown_(NighthawkService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC,
                          channel) {}

::grpc::Status
NighthawkService::Stub::QueueSession(::grpc::ClientContext* context,
                                     const ::nighthawk::client::QueueSessionRequest& request,
                                     ::nighthawk::client::QueueSessionResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_QueueSession_, context,
                                             request, response);
}

void NighthawkService::Stub::experimental_async::QueueSession(
    ::grpc::ClientContext* context, const ::nighthawk::client::QueueSessionRequest* request,
    ::nighthawk::client::QueueSessionResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_QueueSession_,
                                             context, request, response, std::move(f));
}

void NighthawkService::Stub::experimental_async::QueueSession(
    ::grpc::ClientContext* context, const ::grpc::ByteBuffer* request,
    ::nighthawk::client::QueueSessionResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_QueueSession_,
                                             context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::QueueSessionResponse>*
NighthawkService::Stub::AsyncQueueSessionRaw(
    ::grpc::ClientContext* context, const ::nighthawk::client::QueueSessionRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::QueueSessionResponse>::Create(channel_.get(), cq,
                                                         rpcmethod_QueueSession_, context, request,
                                                         true);
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::QueueSessionResponse>*
NighthawkService::Stub::PrepareAsyncQueueSessionRaw(
    ::grpc::ClientContext* context, const ::nighthawk::client::QueueSessionRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::QueueSessionResponse>::Create(channel_.get(), cq,
                                                         rpcmethod_QueueSession_, context, request,
                                                         false);
}

::grpc::Status NighthawkService::Stub::ReconfigureSession(
    ::grpc::ClientContext* context, const ::nighthawk::client::ReconfigureSessionRequest& request,
    ::nighthawk::client::ReconfigureSessionResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ReconfigureSession_, context,
                                             request, response);
}

void NighthawkService::Stub::experimental_async::ReconfigureSession(
    ::grpc::ClientContext* context, const ::nighthawk::client::ReconfigureSessionRequest* request,
    ::nighthawk::client::ReconfigureSessionResponse* response,
    std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(),
                                             stub_->rpcmethod_ReconfigureSession_, context, request,
                                             response, std::move(f));
}

void NighthawkService::Stub::experimental_async::ReconfigureSession(
    ::grpc::ClientContext* context, const ::grpc::ByteBuffer* request,
    ::nighthawk::client::ReconfigureSessionResponse* response,
    std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(),
                                             stub_->rpcmethod_ReconfigureSession_, context, request,
                                             response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::ReconfigureSessionResponse>*
NighthawkService::Stub::AsyncReconfigureSessionRaw(
    ::grpc::ClientContext* context, const ::nighthawk::client::ReconfigureSessionRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::ReconfigureSessionResponse>::Create(channel_.get(), cq,
                                                               rpcmethod_ReconfigureSession_,
                                                               context, request, true);
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::ReconfigureSessionResponse>*
NighthawkService::Stub::PrepareAsyncReconfigureSessionRaw(
    ::grpc::ClientContext* context, const ::nighthawk::client::ReconfigureSessionRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::ReconfigureSessionResponse>::Create(channel_.get(), cq,
                                                               rpcmethod_ReconfigureSession_,
                                                               context, request, false);
}

::grpc::Status NighthawkService::Stub::IsSessionFinished(
    ::grpc::ClientContext* context, const ::nighthawk::client::IsSessionFinishedRequest& request,
    ::nighthawk::client::IsSessionFinishedResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_IsSessionFinished_, context,
                                             request, response);
}

void NighthawkService::Stub::experimental_async::IsSessionFinished(
    ::grpc::ClientContext* context, const ::nighthawk::client::IsSessionFinishedRequest* request,
    ::nighthawk::client::IsSessionFinishedResponse* response,
    std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(),
                                             stub_->rpcmethod_IsSessionFinished_, context, request,
                                             response, std::move(f));
}

void NighthawkService::Stub::experimental_async::IsSessionFinished(
    ::grpc::ClientContext* context, const ::grpc::ByteBuffer* request,
    ::nighthawk::client::IsSessionFinishedResponse* response,
    std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(),
                                             stub_->rpcmethod_IsSessionFinished_, context, request,
                                             response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::IsSessionFinishedResponse>*
NighthawkService::Stub::AsyncIsSessionFinishedRaw(
    ::grpc::ClientContext* context, const ::nighthawk::client::IsSessionFinishedRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::IsSessionFinishedResponse>::Create(channel_.get(), cq,
                                                              rpcmethod_IsSessionFinished_, context,
                                                              request, true);
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::IsSessionFinishedResponse>*
NighthawkService::Stub::PrepareAsyncIsSessionFinishedRaw(
    ::grpc::ClientContext* context, const ::nighthawk::client::IsSessionFinishedRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::IsSessionFinishedResponse>::Create(channel_.get(), cq,
                                                              rpcmethod_IsSessionFinished_, context,
                                                              request, false);
}

::grpc::Status NighthawkService::Stub::PopSessionResult(
    ::grpc::ClientContext* context, const ::nighthawk::client::PopSessionResultRequest& request,
    ::nighthawk::client::PopSessionResultResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_PopSessionResult_, context,
                                             request, response);
}

void NighthawkService::Stub::experimental_async::PopSessionResult(
    ::grpc::ClientContext* context, const ::nighthawk::client::PopSessionResultRequest* request,
    ::nighthawk::client::PopSessionResultResponse* response,
    std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(),
                                             stub_->rpcmethod_PopSessionResult_, context, request,
                                             response, std::move(f));
}

void NighthawkService::Stub::experimental_async::PopSessionResult(
    ::grpc::ClientContext* context, const ::grpc::ByteBuffer* request,
    ::nighthawk::client::PopSessionResultResponse* response,
    std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(),
                                             stub_->rpcmethod_PopSessionResult_, context, request,
                                             response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::PopSessionResultResponse>*
NighthawkService::Stub::AsyncPopSessionResultRaw(
    ::grpc::ClientContext* context, const ::nighthawk::client::PopSessionResultRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::PopSessionResultResponse>::Create(channel_.get(), cq,
                                                             rpcmethod_PopSessionResult_, context,
                                                             request, true);
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::PopSessionResultResponse>*
NighthawkService::Stub::PrepareAsyncPopSessionResultRaw(
    ::grpc::ClientContext* context, const ::nighthawk::client::PopSessionResultRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::PopSessionResultResponse>::Create(channel_.get(), cq,
                                                             rpcmethod_PopSessionResult_, context,
                                                             request, false);
}

::grpc::Status NighthawkService::Stub::Shutdown(::grpc::ClientContext* context,
                                                const ::nighthawk::client::ShutdownRequest& request,
                                                ::nighthawk::client::ShutdownResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Shutdown_, context, request,
                                             response);
}

void NighthawkService::Stub::experimental_async::Shutdown(
    ::grpc::ClientContext* context, const ::nighthawk::client::ShutdownRequest* request,
    ::nighthawk::client::ShutdownResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Shutdown_,
                                             context, request, response, std::move(f));
}

void NighthawkService::Stub::experimental_async::Shutdown(
    ::grpc::ClientContext* context, const ::grpc::ByteBuffer* request,
    ::nighthawk::client::ShutdownResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Shutdown_,
                                             context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::ShutdownResponse>*
NighthawkService::Stub::AsyncShutdownRaw(::grpc::ClientContext* context,
                                         const ::nighthawk::client::ShutdownRequest& request,
                                         ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::ShutdownResponse>::Create(channel_.get(), cq, rpcmethod_Shutdown_,
                                                     context, request, true);
}

::grpc::ClientAsyncResponseReader<::nighthawk::client::ShutdownResponse>*
NighthawkService::Stub::PrepareAsyncShutdownRaw(::grpc::ClientContext* context,
                                                const ::nighthawk::client::ShutdownRequest& request,
                                                ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::nighthawk::client::ShutdownResponse>::Create(channel_.get(), cq, rpcmethod_Shutdown_,
                                                     context, request, false);
}

NighthawkService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NighthawkService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<NighthawkService::Service,
                                             ::nighthawk::client::QueueSessionRequest,
                                             ::nighthawk::client::QueueSessionResponse>(
          std::mem_fn(&NighthawkService::Service::QueueSession), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NighthawkService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<NighthawkService::Service,
                                             ::nighthawk::client::ReconfigureSessionRequest,
                                             ::nighthawk::client::ReconfigureSessionResponse>(
          std::mem_fn(&NighthawkService::Service::ReconfigureSession), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NighthawkService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<NighthawkService::Service,
                                             ::nighthawk::client::IsSessionFinishedRequest,
                                             ::nighthawk::client::IsSessionFinishedResponse>(
          std::mem_fn(&NighthawkService::Service::IsSessionFinished), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NighthawkService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<NighthawkService::Service,
                                             ::nighthawk::client::PopSessionResultRequest,
                                             ::nighthawk::client::PopSessionResultResponse>(
          std::mem_fn(&NighthawkService::Service::PopSessionResult), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      NighthawkService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<NighthawkService::Service,
                                             ::nighthawk::client::ShutdownRequest,
                                             ::nighthawk::client::ShutdownResponse>(
          std::mem_fn(&NighthawkService::Service::Shutdown), this)));
}

NighthawkService::Service::~Service() {}

::grpc::Status
NighthawkService::Service::QueueSession(::grpc::ServerContext* context,
                                        const ::nighthawk::client::QueueSessionRequest* request,
                                        ::nighthawk::client::QueueSessionResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NighthawkService::Service::ReconfigureSession(
    ::grpc::ServerContext* context, const ::nighthawk::client::ReconfigureSessionRequest* request,
    ::nighthawk::client::ReconfigureSessionResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NighthawkService::Service::IsSessionFinished(
    ::grpc::ServerContext* context, const ::nighthawk::client::IsSessionFinishedRequest* request,
    ::nighthawk::client::IsSessionFinishedResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status NighthawkService::Service::PopSessionResult(
    ::grpc::ServerContext* context, const ::nighthawk::client::PopSessionResultRequest* request,
    ::nighthawk::client::PopSessionResultResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status
NighthawkService::Service::Shutdown(::grpc::ServerContext* context,
                                    const ::nighthawk::client::ShutdownRequest* request,
                                    ::nighthawk::client::ShutdownResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

} // namespace client
} // namespace nighthawk
